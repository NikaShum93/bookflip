<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Teachy Witchy — Book Viewer</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/css/page-flip.min.css">
<style>
  /* прозрачный фон, жесты включены */
  html,body{margin:0;height:100%;background:transparent;overflow:hidden;touch-action:manipulation}

  /* сцена центрирует книгу и НЕ режет анимацию */
  .scene{position:relative;width:100%;height:100%;background:transparent;display:flex;align-items:center;justify-content:center;overflow:visible}

  /* «рамка» натурального размера книги (2w × h); на неё вешаем scale */
  .book-frame{position:relative;transform-origin:center center;will-change:transform}

  /* сам виджет */
  #book{width:100%;height:100%;background:transparent}

  /* НИЧЕГО не режем внутри библиотеки — чтобы волна не обрезалась */
  .stf__wrapper,.stf__block,.stf__item,.stf__page,.stf__content{
    overflow:visible!important;background:transparent!important;margin:0!important;padding:0!important;border:0!important;box-shadow:none!important
  }

  /* одна страница = одно изображение, без деформации и без перехвата клика */
  .page{position:relative;width:100%;height:100%}
  .page img{width:100%;height:100%;object-fit:contain;display:block;user-select:none;-webkit-user-drag:none;pointer-events:none}

  /* виньетки по краям (как в твоей «рабочей») */
  .stf__item--left::after, .stf__item--right::after{
    content:""; position:absolute; inset:0; pointer-events:none; mix-blend-mode:multiply;
  }
  .stf__item--left::after{  background:linear-gradient(90deg, rgba(0,0,0,.22) 0%, rgba(0,0,0,0) 14%) }
  .stf__item--right::after{ background:linear-gradient(270deg, rgba(0,0,0,.22) 0%, rgba(0,0,0,0) 14%) }

  /* корешковая тень (на развороте), не выходит за край страницы */
  .stf__item--left::before, .stf__item--right::before{
    content:""; position:absolute; top:0; bottom:0; width:3%; pointer-events:none; mix-blend-mode:multiply; opacity:.4;
  }
  .stf__item--left::before{  right:0; background:linear-gradient(90deg, rgba(0,0,0,.60), rgba(0,0,0,0)) }
  .stf__item--right::before{ left:0;  background:linear-gradient(90deg, rgba(0,0,0,0), rgba(0,0,0,.60)) }

  /* тень «книга лежит на столе»: вокруг страниц (drop-shadow), не мешает кликам */
  .stf__item{
    filter:
      drop-shadow(0 18px 22px rgba(0,0,0,.28))
      drop-shadow(0  4px 10px rgba(0,0,0,.20));
    pointer-events:auto; /* клики проходят на элемент */
  }
  /* когда только обложка/задник — тень мягче и БЕЗ корешка */
  .book-frame.single .stf__item{
    filter:
      drop-shadow(0 14px 18px rgba(0,0,0,.22))
      drop-shadow(0  2px  8px rgba(0,0,0,.16));
  }
  .book-frame.single .stf__item::before{ display:none }
  .book-frame.single .stf__item--left::after,
  .book-frame.single .stf__item--right::after{ background:none }
</style>
</head>
<body>
  <div id="scene" class="scene">
    <div id="frame" class="book-frame">
      <div id="book"></div>
    </div>
  </div>

  <audio id="flipSound" preload="auto" src="https://raw.githubusercontent.com/NikaShum93/bookflip/main/flip.mp3"></audio>
  <script src="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/js/page-flip.browser.min.js"></script>
  <script>
  (function(){
    const qs = new URLSearchParams(location.search);

    // двойное декодирование imgs на случай %253A
    const urls = (qs.get('imgs')||'')
      .split(/[|,]/).map(s=>s.trim()).filter(Boolean)
      .map(s=>{ try{ return decodeURIComponent(decodeURIComponent(s)) }catch(_){ try{ return decodeURIComponent(s) }catch(_){ return s } } })
      .filter(Boolean);
    if (!urls.length) return;

    const flipTime = +qs.get('flipTime')>0 ? +qs.get('flipTime') : 800;
    const pageW = parseInt(qs.get('w'),10) || 600;
    const pageH = parseInt(qs.get('h'),10) || 900;

    // «воздух» вокруг книги, чтобы волна не резалась (регулируется при желании)
    const padX = Math.round(pageW * 0.14);
    const padY = Math.round(pageH * 0.18);

    const scene  = document.getElementById('scene');
    const frame  = document.getElementById('frame');
    const bookEl = document.getElementById('book');

    // рамка книги = 2w × h
    frame.style.width  = (pageW * 2) + 'px';
    frame.style.height =  pageH + 'px';

    // подгон под iframe с учётом «воздуха»
    function fit(){
      const needW = pageW*2 + padX*2;
      const needH = pageH   + padY*2;
      const scale = Math.min(scene.clientWidth / needW, scene.clientHeight / needH);
      frame.style.transform = 'scale(' + scale + ')';
    }
    addEventListener('resize', fit, {passive:true}); fit();

    // инициализация PageFlip (как в твоей рабочей)
    const pf = new St.PageFlip(bookEl, {
      width: pageW,
      height: pageH,
      size: 'fixed',
      autoSize: false,
      showCover: true,
      usePortrait: false,
      flippingTime: flipTime,
      maxShadowOpacity: 0.85,
      drawShadow: true,
      mobileScrollSupport: true,
      useMouseEvents: true,
      clickEventForward: false,
      showHint: false
    });

    // наполняем страницами
    const host = document.createElement('div');
    urls.forEach((src,i)=>{
      const p = document.createElement('div'); p.className='page';
      p.setAttribute('data-density', (i===0 || i===urls.length-1) ? 'hard' : 'soft');
      const img = document.createElement('img'); img.src = src; img.alt='';
      p.appendChild(img); host.appendChild(p);
    });
    const nodes = host.querySelectorAll('.page');
    if (typeof pf.loadFromHTML === 'function') pf.loadFromHTML(nodes); else pf.loadFromImages(urls);

    // обложка/задник — «single», чтобы убрать корешковую тень и тень слева от обложки
    function syncSingle(){
      const idx = pf.getCurrentPageIndex();
      frame.classList.toggle('single', (idx===0 || idx===urls.length-1));
    }
    syncSingle(); pf.on('flip', syncSingle);

    // звук
    const flipSound = document.getElementById('flipSound');
    pf.on('flip', ()=>{ try{ flipSound.currentTime=0; flipSound.play(); }catch(e){} });

    // железобетонные клики: считаем относительно реального прямоугольника книги (работает и при больших размерах)
    let lock=false;
    function go(dir){
      if (lock || pf.isFlipping()) return;
      lock = true;
      (dir==='prev') ? pf.flipPrev('top') : pf.flipNext('top');
      setTimeout(()=>{ lock=false; }, pf.getSettings().flippingTime + 60);
    }

    // основной обработчик — на самом блоке книги
    bookEl.addEventListener('pointerdown', (e)=>{
      const r = bookEl.getBoundingClientRect();
      const x = (e.clientX || 0) - r.left;
      go(x < r.width/2 ? 'prev' : 'next');
      e.preventDefault();
    }, {passive:false});

    // страховка для Genially (если родитель перехватывает события)
    window.addEventListener('pointerdown', (e)=>{
      if (!e.target.closest('#book')) return;
      const r = bookEl.getBoundingClientRect();
      const x = (e.clientX || 0) - r.left;
      go(x < r.width/2 ? 'prev' : 'next');
      e.preventDefault();
    }, {passive:false, capture:true});

    // клавиатура
    window.addEventListener('keydown', (e)=>{
      if (e.key==='ArrowLeft')  go('prev');
      if (e.key==='ArrowRight') go('next');
    });
  })();
  </script>
</body>
</html>
