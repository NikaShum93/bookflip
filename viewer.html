<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Teachy Witchy — Book Viewer</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/css/page-flip.min.css">
<style>
  /* Прозрачный фон iframe, ничего лишнего не перехватывает */
  html,body{margin:0;height:100%;background:transparent;overflow:hidden;touch-action:manipulation}

  /* Сцена = весь iframe */
  .scene{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:transparent;overflow:hidden}

  /* Рамка натурального размера книги (2*w × h); на неё вешаем scale */
  .book-frame{position:relative;transform-origin:center center;will-change:transform;background:transparent}
  #book{width:100%;height:100%;background:transparent}

  /* Сбрасываем любые фон/поля/тени у библиотеки, чтобы не мешать кликам */
  .stf__wrapper,.stf__block,.stf__item,.stf__page,.stf__content{
    background:transparent!important;margin:0!important;padding:0!important;border:0!important;box-shadow:none!important
  }
  .stf__page{overflow:hidden}

  /* Контент — просто изображения без деформации */
  .page{position:relative;width:100%;height:100%}
  .page img{
    width:100%;height:100%;object-fit:contain;display:block;
    user-select:none;-webkit-user-drag:none;pointer-events:none
  }

  /* Оверлей ошибок (если imgs пустой и т.п.) */
  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.25);color:#fff;font:14px/1.4 system-ui,Segoe UI,Roboto,Arial;z-index:9999}
  .overlay.show{display:flex}
  .overlay .panel{background:#121212;border:1px solid #333;border-radius:12px;padding:12px 14px;max-width:720px}
</style>
</head>
<body>
  <div id="scene" class="scene">
    <div id="frame" class="book-frame" aria-label="flipbook">
      <div id="book"></div>
    </div>
    <div id="ovl" class="overlay"><div class="panel" id="ovlMsg">Ошибка</div></div>
  </div>

  <audio id="flipSound" preload="auto" src="https://raw.githubusercontent.com/NikaShum93/bookflip/main/flip.mp3"></audio>
  <script src="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/js/page-flip.browser.min.js"></script>
  <script>
  (function(){
    const qs = new URLSearchParams(location.search);
    const urls = (qs.get('imgs')||'')
      .split(/[|,]/).map(s=>s.trim()).filter(Boolean)
      .map(s=>{ try { return decodeURIComponent(s) } catch { return s } });

    if (!urls.length) return err('Пустой imgs — нет изображений.');

    const flipTime = +qs.get('flipTime') > 0 ? +qs.get('flipTime') : 800;

    // Исходный размер ОДНОЙ страницы (что пришло в URL)
    let pageW = parseInt(qs.get('w'),10) || 600;
    let pageH = parseInt(qs.get('h'),10) || 900;

    const scene  = document.getElementById('scene');
    const frame  = document.getElementById('frame');
    const bookEl = document.getElementById('book');

    // Жёсткий безопасный потолок (две страницы ≤ 1800, высота ≤ 1200)
    function clampToSafeCaps(w, h){
      const capW2 = 1800; // для двух страниц
      const capH  = 1200;
      const s = Math.min(capW2/(2*w), capH/h, 1);
      return { w: Math.round(w*s), h: Math.round(h*s) };
    }

    // Подгон под контейнер так, чтобы итоговый SCALE был ≥ MIN_SCALE
    const MIN_SCALE = 0.35;
    function fitInitialToScene(w, h){
      // сначала жёсткий кап
      let {w:W, h:H} = clampToSafeCaps(w, h);
      // оценим масштаб, который получится на текущей сцене
      const availW = scene.clientWidth || window.innerWidth;
      const availH = scene.clientHeight || window.innerHeight;
      const needW  = W*2;
      const needH  = H;
      let scale    = Math.min(availW/needW, availH/needH);

      if (scale < MIN_SCALE) {
        // уменьшим «нативный» размер страницы так, чтобы новый scale стал ≈ MIN_SCALE
        // scale' = min(availW/(2*W'), availH/H')  -> хотим scale' = MIN_SCALE
        // => W' = min(W, floor(availW/(2*MIN_SCALE))); H' = min(H, floor(availH/MIN_SCALE))
        const maxWPerPage = Math.floor(availW/(2*MIN_SCALE));
        const maxHPerPage = Math.floor(availH/(MIN_SCALE));
        const s2 = Math.min(maxWPerPage/W, maxHPerPage/H, 1);
        W = Math.max(200, Math.round(W*s2));
        H = Math.max(200, Math.round(H*s2));
      }
      return { w: W, h: H };
    }

    // Дадим браузеру отрисовать сцену и только потом считаем
    requestAnimationFrame(()=>{
      const { w:effW, h:effH } = fitInitialToScene(pageW, pageH);
      pageW = effW; pageH = effH;

      // Размер рамки в «нативных» пикселях книги
      function setFrameSize(){
        frame.style.width  = (pageW * 2) + 'px';
        frame.style.height = pageH + 'px';
        fitToScene(); // сразу подогнать масштаб
      }

      // Масштабируем книгу целиком в центр, без обрезаний
      function fitToScene(){
        const availW = scene.clientWidth;
        const availH = scene.clientHeight;
        const needW  = pageW * 2;
        const needH  = pageH;
        const scale  = Math.min(availW/needW, availH/needH);
        frame.style.transform = 'scale(' + scale + ')';
      }

      setFrameSize();
      addEventListener('resize', fitToScene, {passive:true});

      // Инициализация PageFlip
      const pf = new St.PageFlip(bookEl, {
        width: pageW,
        height: pageH,
        size: 'fixed',
        autoSize: false,
        showCover: true,        // обложка и задняя — жёсткие
        usePortrait: false,     // всегда разворот
        flippingTime: flipTime,
        maxShadowOpacity: 0.85, // волна сочнее
        drawShadow: true,
        mobileScrollSupport: true,
        useMouseEvents: true,
        clickEventForward: false,
        showHint: false
      });

      // Генерация страниц
      const host = document.createElement('div');
      urls.forEach((src,i)=>{
        const p = document.createElement('div'); p.className='page';
        p.setAttribute('data-density', (i===0 || i===urls.length-1) ? 'hard' : 'soft');
        const img = document.createElement('img'); img.src = src; img.alt='';
        p.appendChild(img); host.appendChild(p);
      });
      const nodes = host.querySelectorAll('.page');
      if (typeof pf.loadFromHTML === 'function') pf.loadFromHTML(nodes);
      else pf.loadFromImages(urls);

      // Сингл-режим для обложки/задника (если нужно что-то отличать)
      function syncSingle(){
        const idx = pf.getCurrentPageIndex();
        frame.classList.toggle('single', (idx===0 || idx===urls.length-1));
      }
      syncSingle(); pf.on('flip', syncSingle);

      // Звук
      const flipSound = document.getElementById('flipSound');
      pf.on('flip', ()=>{ try{ flipSound.currentTime=0; flipSound.play(); }catch(e){} });

      // Безопасное листание: защита от дабл-клика
      let lock=false;
      function safeFlip(dir){
        if (lock || pf.isFlipping()) return;
        lock = true;
        (dir==='prev') ? pf.flipPrev('top') : pf.flipNext('top');
        setTimeout(()=>{ lock=false; }, pf.getSettings().flippingTime + 60);
      }

      // Логика кликов:
      // - Внутри разворота: левая половина = prev, правая = next.
      // - На обложке (первая страница): только правая внешняя кромка (последние 25%) открывает книгу.
      // - На заднике (последняя): только левая внешняя кромка (первые 25%) закрывает назад.
      scene.addEventListener('pointerdown', (e)=>{
        // генерик-проверки
        const r = scene.getBoundingClientRect();
        const x = e.clientX - r.left;
        const y = e.clientY - r.top;
        // нормализуем к рамке (учитывая текущий scale)
        const m = frame.getBoundingClientRect();
        if (x < m.left - r.left || x > m.right - r.left || y < m.top - r.top || y > m.bottom - r.top){
          return;
        }
        e.preventDefault();

        const idx = pf.getCurrentPageIndex();
        const last = urls.length - 1;

        const half = (m.left - r.left) + (m.width / 2);
        const isLeft  = x < half;
        const isRight = x >= half;

        if (idx === 0) {
          // закрытая книга: открыть только кликом у правого края
          const rightEdge = m.left - r.left + m.width * 0.75;
          if (x >= rightEdge) safeFlip('next');
          return;
        }
        if (idx === last) {
          // задняя обложка: закрыть только кликом у левого края
          const leftEdge = m.left - r.left + m.width * 0.25;
          if (x <= leftEdge) safeFlip('prev');
          return;
        }

        // Обычные развороты
        safeFlip(isLeft ? 'prev' : 'next');
      }, {passive:false});

      // Клавиатура
      addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft')  safeFlip('prev');
        if (e.key === 'ArrowRight') safeFlip('next');
      });

      function err(msg){
        const o=document.getElementById('ovl'), m=document.getElementById('ovlMsg');
        m.textContent=msg; o.classList.add('show');
      }
    });

  })();
  </script>
</body>
</html>
