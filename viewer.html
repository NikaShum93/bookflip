<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Teachy Witchy — Book Viewer</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/css/page-flip.min.css">
<style>
  html,body{margin:0;height:100%;background:transparent;overflow:hidden}
  .scene{position:relative;width:100%;height:100%;background:transparent;display:flex;align-items:center;justify-content:center}
  /* ВАЖНО: без transform и без padding — клики стабильные */
  .book-frame{position:relative;transform-origin:center center;will-change:auto;pointer-events:auto}
  #book{width:100%;height:100%;background:transparent;pointer-events:auto}

  /* сброс библиотечных теней */
  .stf__wrapper,.stf__block,.stf__item,.stf__page,.stf__content{
    background:transparent !important;margin:0 !important;padding:0 !important;border:0 !important;box-shadow:none !important;
  }
  .stf__page{overflow:hidden}
  .page{width:100%;height:100%;position:relative}
  .page img{
    width:100%;height:100%;
    object-fit:contain;
    display:block;user-select:none;-webkit-user-drag:none;pointer-events:none;
  }

  /* виньетки по краям страниц */
  .stf__item--left::after, .stf__item--right::after{
    content:""; position:absolute; inset:0; pointer-events:none; mix-blend-mode:multiply;
  }
  .stf__item--left::after{
    background:linear-gradient(90deg, rgba(0,0,0,.22) 0%, rgba(0,0,0,0) 14%);
  }
  .stf__item--right::after{
    background:linear-gradient(270deg, rgba(0,0,0,.22) 0%, rgba(0,0,0,0) 14%);
  }

  /* внутренняя тень у корешка */
  .stf__item--left::before, .stf__item--right::before{
    content:""; position:absolute; top:0; bottom:0; width:3%;
    pointer-events:none; mix-blend-mode:multiply; opacity:.4;
  }
  .stf__item--left::before{ right:0;  background:linear-gradient(90deg, rgba(0,0,0,.6), rgba(0,0,0,0)); }
  .stf__item--right::before{ left:0;   background:linear-gradient(90deg, rgba(0,0,0,0), rgba(0,0,0,.6)); }

  /* ТЕНЬ ПОД КНИГОЙ ПО ПЕРИМЕТРУ */
  .stf__item{
    filter:
      drop-shadow(0 18px 22px rgba(0,0,0,.28))
      drop-shadow(0 4px 10px rgba(0,0,0,.20));
  }
  /* для обложки/задника (одна страница) — мягче */
  .book-frame.single .stf__item{
    filter:
      drop-shadow(0 14px 18px rgba(0,0,0,.22))
      drop-shadow(0 2px 8px rgba(0,0,0,.16));
  }

  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.25);color:#fff;font:14px/1.4 system-ui,Segoe UI,Roboto,Arial;z-index:9999}
  .overlay.show{display:flex}
  .overlay .panel{background:#121212;border:1px solid #333;border-radius:12px;padding:12px 14px;max-width:720px}
</style>
</head>
<body>
  <div id="scene" class="scene">
    <div id="frame" class="book-frame">
      <div id="book"></div>
    </div>
    <div id="ovl" class="overlay"><div class="panel" id="ovlMsg">Ошибка</div></div>
  </div>

  <audio id="flipSound" preload="auto" src="https://raw.githubusercontent.com/NikaShum93/bookflip/main/flip.mp3"></audio>
  <script src="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/js/page-flip.browser.min.js"></script>
  <script>
  (function(){
    const qs = new URLSearchParams(location.search);
    const urls = (qs.get('imgs')||'')
      .split(/[|,]/).map(s=>s.trim()).filter(Boolean)
      .map(s=>{try{return decodeURIComponent(s)}catch{return s}});
    if (!urls.length) return err('Пустой imgs — нет изображений.');

    const flipTime = +qs.get('flipTime') > 0 ? +qs.get('flipTime') : 800;

    // БАЗОВЫЕ размеры страницы (логические)
    const baseW = parseInt(qs.get('w'),10) || 600;
    const baseH = parseInt(qs.get('h'),10) || 900;

    // «внутренний зазор» в px (но реализуем не padding'ом!)
    const pad = parseInt(qs.get('pad'), 10) || 0;
    const MIN_SCALE = 0.3;

    const scene  = document.getElementById('scene');
    const frame  = document.getElementById('frame');
    const bookEl = document.getElementById('book');

    let pf = null;
    let currentW = 0, currentH = 0;

    // считаем реальный размер книги без transform/padding
    function computeSize(){
      const needW = baseW * 2;
      const needH = baseH;

      const availW = scene.clientWidth;
      const availH = scene.clientHeight;

      // оставляем «поля» по pad с каждой стороны, не используя CSS padding
      const innerW = Math.max(0, availW - pad*2);
      const innerH = Math.max(0, availH - pad*2);

      let s = Math.min(innerW / needW, innerH / needH);
      if (!isFinite(s) || s <= 0) s = MIN_SCALE;
      if (s < MIN_SCALE) s = MIN_SCALE;

      // итоговые реальные размеры страницы и рамки
      const pageW = Math.round(baseW * s);
      const pageH = Math.round(baseH * s);

      return { pageW, pageH, frameW: pageW*2, frameH: pageH };
    }

    function mountFlip() {
      const { pageW, pageH, frameW, frameH } = computeSize();

      // уже такие — ничего не делаем
      if (pf && frameW === currentW && frameH === currentH) return;

      // обновим контейнерные размеры
      currentW = frameW; currentH = frameH;
      frame.style.width  = frameW + 'px';
      frame.style.height = frameH + 'px';
      bookEl.style.width = '100%';
      bookEl.style.height = '100%';

      // если уже был инстанс — удалим DOM и создадим заново (PageFlip не умеет менять width/height на лету)
      if (pf) {
        try { pf.destroy(); } catch(e){}
        bookEl.innerHTML = '';
      }

      pf = new St.PageFlip(bookEl, {
        width: pageW,
        height: pageH,
        size: 'fixed',
        autoSize: false,
        showCover: true,
        usePortrait: false,
        flippingTime: flipTime,
        maxShadowOpacity: 0.85,
        drawShadow: true,
        mobileScrollSupport: true,
        useMouseEvents: true,
        clickEventForward: false,
        showHint: false
      });

      // добавляем страницы
      const host = document.createElement('div');
      urls.forEach((src,i)=>{
        const p = document.createElement('div'); p.className='page';
        p.setAttribute('data-density', (i===0 || i===urls.length-1) ? 'hard' : 'soft');
        const img = document.createElement('img'); img.src = src; img.alt='';
        p.appendChild(img); host.appendChild(p);
      });
      const nodes = host.querySelectorAll('.page');
      if (typeof pf.loadFromHTML === 'function') pf.loadFromHTML(nodes);
      else pf.loadFromImages(urls);

      // одна/две страницы — для мягкой тени
      function syncSingle(){
        const idx = pf.getCurrentPageIndex();
        frame.classList.toggle('single', (idx===0 || idx===urls.length-1));
      }
      syncSingle(); pf.on('flip', syncSingle);

      // звук
      const flipSound = document.getElementById('flipSound');
      pf.on('flip', ()=>{ try{ flipSound.currentTime=0; flipSound.play(); }catch(e){} });

      // зоны клика — по самой книге (без transform всё стабильно)
      let lock=false;
      function safeFlip(dir){
        if (lock || pf.isFlipping()) return;
        lock = true;
        if (dir==='prev') pf.flipPrev('top'); else pf.flipNext('top');
        setTimeout(()=>{ lock=false; }, pf.getSettings().flippingTime + 40);
      }
      function onBookClick(e){
        const r = frame.getBoundingClientRect();
        const x = e.clientX - r.left;
        const half = r.width / 2;
        if (x < half) safeFlip('prev'); else safeFlip('next');
      }
      frame.onclick = onBookClick;
      bookEl.onclick = onBookClick;

      window.onkeydown = (e)=>{
        if (e.key==='ArrowLeft')  safeFlip('prev');
        if (e.key==='ArrowRight') safeFlip('next');
      };
    }

    // первичная инициализация
    mountFlip();

    // дебаунс ресайза, пересоздаём книгу под новое окно
    let rto = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(rto);
      rto = setTimeout(()=> mountFlip(), 120);
    });

    function err(msg){
      const o=document.getElementById('ovl'), m=document.getElementById('ovlMsg');
      m.textContent=msg; o.classList.add('show');
    }
  })();
  </script>
</body>
</html>
